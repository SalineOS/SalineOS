#!/bin/bash
# Licensed under the GNU General Public License Version 2
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
####################################################################################################
#  Copyright 2008,2009,2010,2012 Under the GNU GPL2 License
# Authors Tony Brijeski, Anthony Nordquist http://www.salineos.com salinelinux@gmail.com 


## Set options for yet another dialog, this makes creating dialogs much easier.

Info='yad --center --title=SalineOS-Backup --window-icon=/usr/share/pixmaps/salineos-backup.png'

Question='yad  --wrap --center --image=gtk-dialog-question --button=gtk-no:1 --button=gtk-yes:0 --title=SalineOS-Backup --window-icon=/usr/share/pixmaps/salineos-backup.png'

SingleMenu='yad  --center --list --column=Choices --title=SalineOS-Backup --window-icon=/usr/share/pixmaps/salineos-backup.png'

Menu='yad --print-column=1 --center --list --title=SalineOS-Backup --window-icon=/usr/share/pixmaps/salineos-backup.png'

Progress='yad --center --progress --auto-close --title=SalineOS-Backup --no-buttons --window-icon=/usr/share/pixmaps/salineos-backup.png'

TextEntry='yad --center --entry --title=SalineOS-Backup --window-icon=/usr/share/pixmaps/salineos-backup.png'


SetExcludes () {

Selection=""
Excludes=""
NewExclude=""
CurrentExcludes=""

mkdir -p /etc/salineos-backup

if [ -f /etc/salineos-backup/excludes ]; then
 Excludes=$(cat /etc/salineos-backup/excludes)
fi

CurrentExcludes=$(echo -n "$Excludes" | yad --always-print-result --text-info --height=350 --editable --title="SalineOS Backup" --wrap --width=400 --text="$EXCLUDESINFO" --button=$"gtk-cancel:3" --button=$"$ADDNEW:5" --button=$"gtk-ok:2")

ret="$?"

if [ "$ret" = "252" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "5" ]; then
 if [ -f /etc/salineos-backup/excludes ]; then
  rm /etc/salineos-backup/excludes
 fi
 echo "$CurrentExcludes">>/etc/salineos-backup/excludes
 NewExclude=$(yad --file-selection --title="SalineOS-Backup" --height=450 --width=600 --directory --text="\n                     $SELECTFORF\n" --button=$"gtk-quit:3" --button=$"gtk-ok:2")
 ret="$?"

 if [ "$ret" = "252" ]; then
  SetExcludes
  exit 0
 elif [ "$ret" = "3" ]; then
  exit 0
 else
  echo "$NewExclude">>/etc/salineos-backup/excludes
  SetExcludes
  exit 0
 fi
else
 if [ -f /etc/salineos-backup/excludes ]; then
  rm /etc/salineos-backup/excludes
 fi
 echo "$CurrentExcludes">>/etc/salineos-backup/excludes
 StartBackup
 exit 0
fi

} 

StartBackup () {


SaveFolder=$(yad --file-selection --title="SalineOS-Backup" --height=450 --width=600 --directory --text="$SAVEFOLDER\n                     \n" --button=$"gtk-quit:3" --button=$"gtk-ok:2")

ret="$?"

if [ "$ret" = "252" ]; then
 StartBackup
 exit 0
elif [ "$ret" = "3" ]; then
 exit 0
elif [ "$SaveFolder" = "" ]; then
 StartBackup
 exit 0
fi

ContinueBackup

}

ContinueBackup () { 

ImageName=""

ImageName=$($TextEntry --wrap --width=250 --entry-text="$(date +%Y%m%d-%H%M)" --text="$ENTERNAME" --button=$"gtk-quit:3" --button=$"gtk-ok:2")

ret="$?"

if [ "$ret" = "252" ]; then
 ContinueBackup
 exit 0
elif [ "$ret" = "3" ]; then
 exit 0
elif [ "$ImageName" = "" ]; then
 ImageName=$(date +%Y%m%d-%H%M)
elif [ -f "$SaveFolder/$ImageName" ]; then
 $Question --text="$WARNING "$ImageName" $WARNING1 "$SaveFolder", $WARNING2"
 if [ "$?" != "0" ]; then
  ContinueBackup
  exit 0
 fi
fi

if [ "$BackupPart" = "root" ]; then
 $Info --text="$CLOSEAPPS" --wrap --width=250 --button=$"gtk-quit:3" --button=$"gtk-ok:1"
 UseRoot='/'
fi

ret="$?"

if [ "$ret" = "252" ]; then
 exit 0
elif [ "$ret" = "3" ]; then
 exit 0
fi

E=$(head --lines=1 /etc/salineos-backup/excludes)
E1=$(head -n 2 /etc/salineos-backup/excludes | tail -n 1)
E2=$(head -n 3 /etc/salineos-backup/excludes | tail -n 1)
E3=$(head -n 4 /etc/salineos-backup/excludes | tail -n 1)
E4=$(head -n 5 /etc/salineos-backup/excludes | tail -n 1)
E5=$(head -n 6 /etc/salineos-backup/excludes | tail -n 1)
E6=$(head -n 7 /etc/salineos-backup/excludes | tail -n 1)
E7=$(head -n 8 /etc/salineos-backup/excludes | tail -n 1)
E8=$(head -n 9 /etc/salineos-backup/excludes | tail -n 1)
E9=$(head -n 10 /etc/salineos-backup/excludes | tail -n 1)
E10=$(head -n 11 /etc/salineos-backup/excludes | tail -n 1)
E11=$(head -n 12 /etc/salineos-backup/excludes | tail -n 1)
E12=$(head -n 13 /etc/salineos-backup/excludes | tail -n 1)
E13=$(head -n 14 /etc/salineos-backup/excludes | tail -n 1)
E14=$(head -n 15 /etc/salineos-backup/excludes | tail -n 1)
E15=$(head -n 16 /etc/salineos-backup/excludes | tail -n 1)
E16=$(head -n 17 /etc/salineos-backup/excludes | tail -n 1)
E17=$(head -n 18 /etc/salineos-backup/excludes | tail -n 1)
E18=$(head -n 19 /etc/salineos-backup/excludes | tail -n 1)
E19=$(head -n 20 /etc/salineos-backup/excludes | tail -n 1)
E20=$(head -n 21 /etc/salineos-backup/excludes | tail -n 1)
E21=$(head -n 22 /etc/salineos-backup/excludes | tail -n 1)
E22=$(head -n 23 /etc/salineos-backup/excludes | tail -n 1)
E23=$(head -n 24 /etc/salineos-backup/excludes | tail -n 1)
E24=$(head -n 25 /etc/salineos-backup/excludes | tail -n 1)
E25=$(head -n 26 /etc/salineos-backup/excludes | tail -n 1)
E26=$(head -n 27 /etc/salineos-backup/excludes | tail -n 1)
E27=$(head -n 28 /etc/salineos-backup/excludes | tail -n 1)
E28=$(head -n 29 /etc/salineos-backup/excludes | tail -n 1)
E29=$(head -n 30 /etc/salineos-backup/excludes | tail -n 1)
E30=$(head -n 31 /etc/salineos-backup/excludes | tail -n 1)
E31=$(head -n 32 /etc/salineos-backup/excludes | tail -n 1)
E32=$(head -n 33 /etc/salineos-backup/excludes | tail -n 1)
E33=$(head -n 34 /etc/salineos-backup/excludes | tail -n 1)
E34=$(head -n 35 /etc/salineos-backup/excludes | tail -n 1)
E35=$(head -n 36 /etc/salineos-backup/excludes | tail -n 1)
E36=$(head -n 37 /etc/salineos-backup/excludes | tail -n 1)
E37=$(head -n 38 /etc/salineos-backup/excludes | tail -n 1)
E38=$(head -n 39 /etc/salineos-backup/excludes | tail -n 1)
E39=$(head -n 40 /etc/salineos-backup/excludes | tail -n 1)
E40=$(head -n 41 /etc/salineos-backup/excludes | tail -n 1)
E41=$(head -n 42 /etc/salineos-backup/excludes | tail -n 1)
E42=$(head -n 43 /etc/salineos-backup/excludes | tail -n 1)
E43=$(head -n 44 /etc/salineos-backup/excludes | tail -n 1)
E44=$(head -n 45 /etc/salineos-backup/excludes | tail -n 1)
E45=$(head -n 46 /etc/salineos-backup/excludes | tail -n 1)
E46=$(head -n 47 /etc/salineos-backup/excludes | tail -n 1)
E47=$(head -n 48 /etc/salineos-backup/excludes | tail -n 1)
E48=$(head -n 49 /etc/salineos-backup/excludes | tail -n 1)
E49=$(head -n 50 /etc/salineos-backup/excludes | tail -n 1)
E50=$(head -n 51 /etc/salineos-backup/excludes | tail -n 1)

mksquashfs "$UseRoot" "$SaveFolder/$ImageName.backup" -always-use-fragments -b 1M -comp xz -no-duplicates -no-recovery  -e \
.bash_history \
.cache \
.thumbnails \
boot/grub \
Cache \
"$E" \
"$E1" \
"$E2" \
"$E3" \
"$E4" \
"$E5" \
"$E6" \
"$E7" \
"$E8" \
"$E9" \
"$E10" \
"$E11" \
"$E12" \
"$E13" \
"$E14" \
"$E15" \
"$E16" \
"$E17" \
"$E18" \
"$E19" \
"$E20" \
"$E21" \
"$E22" \
"$E23" \
"$E24" \
"$E25" \
"$E26" \
"$E27" \
"$E28" \
"$E29" \
"$E30" \
"$E31" \
"$E32" \
"$E33" \
"$E34" \
"$E35" \
"$E36" \
"$E37" \
"$E38" \
"$E39" \
"$E40" \
"$E41" \
"$E42" \
"$E43" \
"$E44" \
"$E45" \
"$E46" \
"$E47" \
"$E48" \
"$E49" \
"$E50" \
media \
"$SaveFolder/$ImageName.backup" \
mnt \
proc \
swap \
sys \
tmp \
run >>/tmp/salineos-backup-temp-file &

sleep 1

(while [ "$(pidof mksquashfs)" != "" ]; do
CurrentOutput="$(tail --lines=1 /tmp/salineos-backup-temp-file)"
echo "$CurrentOutput" | awk -F ' ' '{print $NF}' | awk -F '%' '{print $1}' 
done)| yad --center --progress --auto-close --title="SalineOS Backup" --no-buttons --window-icon="/usr/share/pixmaps/salineos-backup.png" --text="$CREATING $ImageName.backup, $PLEASEWAIT..."


## Let all users move the file around
chmod o+rwx "$SaveFolder/$ImageName.backup"

ls /home>>/tmp/salineos-backup-home-list
UserNameTemp=$(tail --lines=1 /tmp/salineos-backup-home-list)

chown "$UserNameTemp" "$SaveFolder/$ImageName.backup" 

rm /tmp/salineos-backup-temp-file

$Info --text="$DONE "$ImageName.backup" $COMPLETE.\n$IMAGESAVED $SaveFolder" --button=$"gtk-ok:1"


exit 0

}


RunInstallation () { 

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="           $PREPDISK           " &


if [ "$Input" = "ext3" ]; then
 FilesystemType="ext3"
else
 FilesystemType="ext4"
fi

if [ "$AutoPart" = "Auto" ]; then 
 parted --script --align optimal /dev/$PartDrive mklabel msdos
 parted --script --align optimal /dev/$PartDrive mkpart primary 1 -- -1
 parted --script --align optimal /dev/$PartDrive set 1 boot on
 TargetHomePart="root"
 TargetPart="$PartDrive"1
fi

if [ "$(mount | grep $TargetPart)" != "" ]; then
 umount /dev/$TargetPart
 umount -l /dev/$TargetPart
 sleep 3
fi

## Perserve labels set by users in GParted
if [ "$(ls /dev/disk/by-label)" != "" ]; then
 LabelRoot=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$TargetPart" | awk '{print $1}' | sed -e 's|\\x20| |g')
fi
sleep 2
mke2fs -t $FilesystemType /dev/$TargetPart

sleep 2

if [ "$LabelRoot" != "" ]; then
 tune2fs -L "$LabelRoot" /dev/$TargetPart
fi

mkdir -p /Target

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="                   Mounting $TargetPart                   " &

mount /dev/$TargetPart /Target -o rw

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --wrap --width="275" --pulsate --text="Configure the filesystem to be checked every 35 mounts" &

tune2fs -c 35 -i 0 /dev/$TargetPart

sleep 3

rm -rf /Target/lost+found

killall -KILL tail

if [ "$TargetHomePart" = "" ]; then
 TargetHomePart="root"
fi

if [ "$TargetHomePart" != "root" ]; then
 if [ "$FormatHome" = "True" ]; then
  tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="           Formatting $TargetHomePart for /home           " &
  umount /dev/$TargetHomePart
  umount -l /dev/$TargetHomePart
  sleep 2
 ## Perserve labels set by users in GParted
 if [ "$(ls /dev/disk/by-label)" != "" ]; then
  LabelHome=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$TargetHomePart" | awk '{print $1}' | sed -e 's|\\x20| |g')
 fi
  sleep 2
  mke2fs -t $FilesystemType /dev/$TargetHomePart
  sleep 3
  if [ "$LabelHome" != "" ]; then
   tune2fs -L "$LabelHome" /dev/$TargetHomePart
  fi
  killall -KILL tail
 fi

 tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="              Mounting $TargetHomePart              " &

 mkdir -p /Target/home

 mount /dev/$TargetHomePart /Target/home -o rw

 tune2fs -c 35 -i 0 /dev/$TargetHomePart

 rm -rf /Target/home/lost+found

 TargetHomeUUID=$(blkid /dev/$TargetHomePart | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')

 ## Get fs type for the home partition in case the user chose not to format it
 HomeFilesystemType=$(mount | grep "/dev/$TargetHomePart" | awk '{print $5}' | awk -F ' ' '{print $1}')

 killall -KILL tail
fi

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="               $GENERATING UUID $VALUESFOR fstab               " &

TargetPartUUID=$(blkid /dev/$TargetPart | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')
TargetCDRom="/dev/cdrom"

sleep 3

killall -KILL tail

## Copy the backup image contents to $Target
tail -f /usr/bin/salineos-backup | $Progress --text="                   $COPYING $TargetPart                   " --pulsate &

## Mount the backup image

mkdir -p /mnt/Super-Happy-Mount-Point

mount "$BackupImage" -o loop /mnt/Super-Happy-Mount-Point

## Rsync
rsync -a /mnt/Super-Happy-Mount-Point/ /Target --ignore-existing --exclude=/{Target,live,cdrom,mnt,proc,sys,media}

## Update the home folders of users if need be

if [ "$TargetHomePart" != "root" ]; then
if [ "$FormatHome" != "True" ]; then
 for i in $(ls /mnt/Super-Happy-Mount-Point/home); do
  cp -rf /mnt/Super-Happy-Mount-Point/home/"$i" /Target/home/
 done
fi
fi

sleep 3

## Unmount backup image
umount -l "/mnt/Super-Happy-Mount-Point"

sleep 1

## Remove mount point
rm -rf /mnt/Super-Happy-Mount-Point

## Make needed aditional folders on the system.
mkdir -p /Target/{proc,dev,mnt,sys,tmp,media/cdrom}
mkdir -p /Target/run

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --text="                    $SETUPSWAP                    " --pulsate &


if [ "$UseSwapFile" = "True" ]; then
 mkdir -p /Target/swap
 fallocate --l "$SwapFileSize"m /Target/swap/salineos-swap
 sleep 2
 mkswap /Target/swap/salineos-swap
 SwapFstab="/swap/salineos-swap"
else
 mkswap "$Swap"
 sleep 2
 blkid
 sleep 2
 TargetSwapUUID=$(blkid /dev/$Swap | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')
 SwapFstab="UUID=$TargetSwapUUID"
fi

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --text="$CHANGECONFIG" --pulsate &

## Make sure all directories are present 
mkdir -p /Target/etc
mkdir -p /Target/usr
mkdir -p /Target/proc
mkdir -p /Target/tmp
mkdir -p /Target/selinux
mkdir -p /Target/home
mkdir -p /Target/bin
mkdir -p /Target/include
mkdir -p /Target/lib
mkdir -p /Target/opt
mkdir -p /Target/srv
mkdir -p /Target/media
mkdir -p /Target/mnt
mkdir -p /Target/dev
mkdir -p /Target/sys
mkdir -p /Target/boot
mkdir -p /Target/sbin
mkdir -p /Target/var
mkdir -p /run/lock

## Prepare a chroot envoirnment for post install changes

mount -o bind /proc /Target/proc
mount -o bind /dev /Target/dev
mount -o bind /sys /Target/sys
rm -rf /Target/etc/fstab

## Create a new fstab file for the system


if [ "$TargetHomePart" = "root" ]; then
cat > /Target/etc/fstab <<FOO
# /etc/fstab: static file system information.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

proc /proc proc defaults 0 0
# Root was on /dev/$TargetPart during install
UUID=$TargetPartUUID / $FilesystemType relatime,errors=remount-ro 0 1
# Swap space created during install
$SwapFstab none swap sw 0 0
# cdrom
$TargetCDRom /media/cdrom udf,iso9660 user,noauto,exec,utf8 0 0


FOO

else

cat > /Target/etc/fstab <<FOO
# /etc/fstab: static file system information.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

proc /proc proc defaults 0 0
# Root was on /dev/$TargetPart during install
UUID=$TargetPartUUID / $FilesystemType relatime,errors=remount-ro 0 1
# /dev/$TargetHomePart home
UUID=$TargetHomeUUID /home $HomeFilesystemType relatime 0 0
# Swap space created during install
$SwapFstab none swap sw 0 0
# cdrom
$TargetCDRom /media/cdrom udf,iso9660 user,noauto,exec,utf8 0 0


FOO

fi

## Make the users on the system own their home folders
for i in $(ls /Target/home); do
 chown -R "$i" /Target/home/"$i"
 chmod og+rw /Target/home/"$i"
done

## Fix permissions on /tmp
chmod og+rw /Target/tmp

sleep 3

killall -KILL tail


## Install GRUB2
tail -f /usr/bin/salineos-backup | $Progress --text="         $INSTALLGRUB         " --pulsate &
chroot /Target chmod -x /etc/grub.d/20_memtest86+
chroot /Target grub-install --force --no-floppy "$GrubLocation"
sleep 2
chroot /Target update-grub
sleep 2



killall -KILL tail

## Unmount the target partition  
tail -f /usr/bin/salineos-backup | $Progress --text="                  Unmounting $TargetPart                  " --pulsate &

sleep 2
umount /Target/home
sleep 2
umount /Target/proc
sleep 2
umount /Target/dev
sleep 2
umount /Target/sys
sleep 2
umount /Target
umount -l /Target
sleep 2

killall -KILL tail

$Question --wrap --width=250 --text="$RESTORECOMPLETE" 

if [ "$?" = "0" ]; then
 reboot
else
 exit 0
fi

}


FinishedMenu () {

Change=""

if [ "$AutoPart" = "Manual" ]; then
 if [ "$UseSwapFile" = "True" ]; then
  SwapFinished='Swap-File'
  SwapFinished2="A $SwapFileSize Megabytes $FMSWAP"
 else
  SwapFinished='Swap-Partition'
  SwapFinished2="$Swap $FMSWAP1"
 fi

RootPartition="Root-Partition"

 if [ "$Input" = "ext3" ]; then
  RootPartition2="$TargetPart $WILLBEFORMATTED (erased) ext3 $ANDUSED root"
 else
  RootPartition2="$TargetPart $WILLBEFORMATTED (erased) ext4 $ANDUSED root"
 fi

HomePartFinished="Home"

 if [ "$TargetHomePart" = "root" ]; then
  HomePartFinished2="$FMHOME"
 else
  if [ "$FormatHome" = "True" ]; then
   if [ "$Input" = "ext3" ]; then
    HomePartFinished2="$TargetHomePart $WILLBEFORMATTED (erased) ext3 $ANDUSED /home"
   else
    HomePartFinished2="$TargetHomePart $WILLBEFORMATTED (erased) ext4 $ANDUSED /home"
   fi
  else
   HomePartFinished2="$TargetHomePart $WILLBEUSED /home "
  fi
 fi
else
 SwapFinished='Swap-File'
 SwapFinished2="A $SwapFileSize Megabytes $FMSWAP"
 RootPartition="Use-Disk"
 RootPartition2="$PartDrive $ENTIREDISK"
fi


GrubFinished="Boot-Loader"
GrubFinished2="$FMGRUB "$GrubLoc""

if [ "$AutoPart" = "Auto" ]; then
Change=$($Menu --height=300 --column="$CURRENTOPTION" --column="$CURRENTSTATUS" --text="$REVIEW.\n" --button=$"gtk-quit:3" --button=$"$CHANGESELECTED:2" --button=$"$RUNINSTALL:5" "$RootPartition" "$RootPartition2" "$SwapFinished" "$SwapFinished2" "$GrubFinished" "$GrubFinished2")
else
Change=$($Menu --height=300 --column="$CURRENTOPTION" --column="$CURRENTSTATUS" --text="$REVIEW.\n" --button=$"gtk-quit:3" --button=$"$CHANGESELECTED:2" --button=$"$RUNINSTALL:5" "$RootPartition" "$RootPartition2" "$SwapFinished" "$SwapFinished2" "$HomePartFinished" "$HomePartFinished2" "$GrubFinished" "$GrubFinished2")
fi

ret="$?"

Change=$(echo "$Change" | awk -F '|' '{print $1}')
 
if [ "$ret" = "252" ]; then
 FinishedMenu
 exit 0 
elif [ "$ret" = "3" ]; then 
  $Question --text="$CXLRESTORE"
  if [ "$?" = "0" ]; then
   if [ -f /tmp/Finished-Menu ]; then
    rm /tmp/Finished-Menu
   fi
   exit 0
  else
   FinishedMenu
   exit 0
  fi
elif [ "$ret" = "5" ]; then
 rm -rf /tmp/Finished-Menu
 RunInstallation
 exit 0
elif [ "$Change" = "Swap-Partition" ]; then
 SelectSwapPart
 exit 0
elif [ "$Change" = "Root-Partition" ]; then
 SelectRootPart
 exit 0
elif [ "$Change" = "Swap-File" ]; then
 SwapFile
 exit 0
elif [ "$Change" = "Home" ]; then
 SelectHomePart
 exit 0
elif [ "$Change" = "Boot-Loader" ]; then
 GrubSelect
 exit 0
elif [ "$Change" = "Use-Disk" ]; then
 ChooseDrive
 exit 0
elif [ "$Change" = "" ]; then
 $Info --text="          $NOCHANGE          \n" --button=$"gtk-ok:1"
 FinishedMenu
 exit 0
fi


rm -rf /tmp/Finished-Menu


}


GrubSelect () {

## Grub location

GrubLocation=""
GrubLoc=""

GrubLoc=$($Menu --width=300 --height=250 --column='$LOCATIONRES' --column=' ' --button=$"gtk-quit:3" --button=$"gtk-ok:2" --text="$GRUBSELECT\n" "${GrubMenu[@]}")

ret="$?"

if [ "$ret" = "252" ]; then
 GrubSelect
 exit 0 
elif [ "$ret" = "3" ]; then 
  $Question --text="$CXLRESTORE"
  if [ "$?" = "0" ]; then
   if [ -f /tmp/Finished-Menu ]; then
    rm /tmp/Finished-Menu
   fi
   exit 0
  else
   GrubSelect
   exit 0
  fi
elif [ "$GrubLoc" = "" ]; then
 $Info --text="$CANNOTBLANK" --button=$"gtk-ok:1"
 GrubSelect
 exit 0
fi

GrubLoc=$(echo "$GrubLoc" | awk -F '|' '{print $1}')

if [ "$GrubLoc" != "root" ]; then
 GrubLocation="/dev/$GrubLoc"
else
 GrubLocation="/dev/$TargetPart"
fi

touch /tmp/Finished-Menu

FinishedMenu

}

SelectHomePart () {

HomePartMenu=""
Partitions=""

Partitions="$(fdisk -l | grep '/dev/' | grep -v "Disk" | grep -v "Extended" | grep -v "$TargetPart" | grep -v "swap" | grep -v 'p1' | grep -v "extended" | grep -v "Hidden" | cut -d " " -f1 | sed 's|/dev/||g')"

for i in $Partitions; do
## Get the label of the disk if available
 Label=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$i" | awk '{print $1}' | sed -e 's|\\x20| |g')

if [ "$Label" = "" ]; then
 Label=' '
else
 Label="$Label     "
fi

PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')
## Part Drive Size is in blocks, first we need to convert the blocks to bytes
## Don't bother with extended partitions
if [ "$PartDriveSize" != "1" ]; then
  BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))
fi

if [ "$(echo "$i" | grep [0-9] )" != "" ]; then
 if [ "$PartDriveSize" != "1" ]; then
  if [ "$HomePartMenu" = "" ]; then
   HomePartMenu=("$i" "$Label" "$SizeInGB" "$SizeInMB")
  else
   HomePartMenu=("${HomePartMenu[@]}" "$i" "$Label" "$SizeInGB" "$SizeInMB")
  fi
 fi
fi

done
HomePart=$($Menu --width="575" --text="  $HOMEPARTLOC\n" --height=400 --column="$NAME" --column="$PARTLABEL" --column="$SIZEINGIB" --column="$SIZEINMIB" --button=$"gtk-quit:3" --button=$"$USESELECTED:2" --button=$"$PUTHOME:5" "${HomePartMenu[@]}")

ret="$?"

if [ "$ret" = "252" ]; then
 SelectHomePart
 exit 0
elif [ "$ret" = "3" ]; then
  $Question --text="$CXLINSTALL"
  if [ "$?" = "0" ]; then
   if [ -f /tmp/Finished-Menu ]; then
    rm /tmp/Finished-Menu
   fi
   exit 1
  else
   SelectSwapPart
   exit 0
  fi
elif [ "$ret" = "5" ]; then
 if [ -f /tmp/Finished-Menu ]; then
  TargetHomePart="root"
  FinishedMenu
  exit 0
 fi
 TargetHomePart="root"
 GrubSelect
 exit 0
elif [ "$HomePart" = "" ]; then
 SelectHomePart
 exit 0
else
 TargetHomePart=$(echo "$HomePart" | awk -F '|' '{print $1}')
 $Question --text="$FORMATHOME, $TargetHomePart?"
  if [ "$?" = "0" ]; then
   FormatHome="True"
  else
   FormatHome="False"
  fi
fi

if [ -f /tmp/Finished-Menu ]; then
 FinishedMenu
 exit 0
else
GrubSelect
exit 0
fi


}


SelectSwapPart () {

SwapPartMenu=""
Swap=""
BlockSize=""

## Find swap partitions and find out which to use.
TargetSwap=$(fdisk -l | grep "swap" | cut -d " " -f1)
TargetSwap=$(echo "$TargetSwap" | sed -r "s/\/dev\///g")



for i in $TargetSwap; do
PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')

## Part Drive Size is in blocks, first we need to convert the blocks to bytes
BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))

if [ "$(echo "$i" | grep [0-9] )" != "" ]; then
 if [ "$SwapPartMenu" = "" ]; then
  SwapPartMenu=("$i" "$SizeInGB" "$SizeInMB")
 else
  SwapPartMenu=("${SwapPartMenu[@]}" "$i" "$SizeInGB" "$SizeInMB")
 fi
fi

done


Swap=$($Menu --width=415 --height=250 --text="            $SWAPPART            \n" --column="$NAME" --column="$SIZEINGIB" --column="$SIZEINMIB" --button=$"gtk-quit:3" --button=$"Use Swap File:5" --button=$"$USESELECTED:2" "${SwapPartMenu[@]}")

ret="$?"



if [ "$ret" = "3" ]; then
  $Question --text="$CXLRESTORE"
  if [ "$?" = "0" ]; then
   if [ -f /tmp/Finished-Menu ]; then
    rm /tmp/Finished-Menu
   fi
   exit 1
  else
   SelectSwapPart
   exit 0
  fi
elif [ "$ret" = "252" ]; then
 SelectSwapPart
 exit 0 
elif [ "$ret" = "5" ]; then
 SwapFile
 exit 0
elif [ "$Swap" = "" ]; then
 SelectSwapPart
 exit 0
elif [ -f /tmp/Finished-Menu ]; then
 Swap=$(echo "$Swap" | awk -F '|' '{print $1}')
 FinishedMenu
 exit 0
else
 HomePartTest="$(fdisk -l | grep '/dev/' | grep -v "Disk" | grep -v 'p1' | grep -v "Extended" | grep -v "$TargetPart" | grep -v "Swap")"
 if [ "$HomePartTest" != "" ]; then
  Swap=$(echo "$Swap" | awk -F '|' '{print $1}')
  SelectHomePart
  exit 0
 fi
 Swap=$(echo "$Swap" | awk -F '|' '{print $1}')
 GrubSelect
 exit 0
fi
 
}

SwapFile () {

SwapFileSize=""

if [ "$AutoPart" = "Auto" ]; then
SwapFileSize=$($Menu --column="Size" --column=" " --text="  $SWAPFILESIZE\n" --button=$"$CONTINUE:2" 8 Megabytes 32 Megabytes 64 Megabytes 128 Megabytes 256 Megabytes 512 Megabytes 1024 Megabytes 2048 "Megabytes $CHOOSETHIS" 3072 Megabytes 4096 Megabytes 5120 Megabytes 6144 Megabytes 8192 Megabytes 16384 Megabytes 30000 Megabytes --height=350 ) 
else
SwapFileSize=$($Menu --column="$SIZE" --column=" " --text="  $SWAPFILESIZE\n" --button=$"Use Swap Partition (Advanced):3" --button=$"$CONTINUESWAP:2" 8 Megabytes 32 Megabytes 64 Megabytes 128 Megabytes 256 Megabytes 512 Megabytes 1024 Megabytes 2048 "Megabytes $CHOOSETHIS" 3072 Megabytes 4096 Megabytes 5120 Megabytes 6144 Megabytes 8192 Megabytes 16384 Megabytes 30000 Megabytes --height=350 ) 
fi

ret="$?"

if [ "$ret" = "3" ]; then
 UseSwapFile="False"
 SelectSwapPart
 exit 0
elif [ "$ret" = "252" ]; then
 SwapFile
 exit 0 
elif [ "$SwapFileSize" = "" ]; then
 SwapFile
 exit 0
else
 UseSwapFile="True"
 SwapFileSize=$(echo "$SwapFileSize" | awk -F '|' '{print $1}') 
  if [ -f /tmp/Finished-Menu ]; then
   FinishedMenu
   exit 0
  elif [ "$AutoPart" = "Auto" ]; then
   GrubSelect
   exit 0
  fi
 HomePartTest="$(fdisk -l | grep '/dev/' | grep -v "Disk" | grep -v 'p1' | grep -v "Extended" | grep -v "$TargetPart" | grep -v "Swap")"
 if [ "$HomePartTest" != "" ]; then
  SelectHomePart
  exit 0
 fi
 GrubSelect
 exit 0
fi

}

## Choose the partition to install to

SelectRootPart () { 

PartDriveMenu=""

Partitions=$(cat /proc/partitions | grep -v loop | grep -v "Extended" | grep -v "extended" | grep -v "swap" | grep -v "Swap" | grep -v "Hidden" | grep -v major | grep -v "^$" | awk '{ print $4}' | grep -v 'p1')

for i in $Partitions; do
## Get the label of the disk if available
 Label=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$i" | awk '{print $1}' | sed -e 's|\\x20| |g')

if [ "$Label" = "" ]; then
 Label=' '
else
 Label="$Label     "
fi

PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')
## Part Drive Size is in blocks, first we need to convert the blocks to bytes
## Don't bother with extended partitions
if [ "$PartDriveSize" != "1" ]; then
  BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))
fi

if [ "$(echo "$i" | grep [0-9] )" != "" ]; then
 if [ "$PartDriveSize" != "1" ]; then
  if [ "$PartDriveMenu" = "" ]; then
   PartDriveMenu=("$i" "$Label" "$SizeInGB" "$SizeInMB")
  else
   PartDriveMenu=("${PartDriveMenu[@]}" "$i" "$Label" "$SizeInGB" "$SizeInMB")
   fi
 fi
fi

done


TargetPart=$($Menu --height=300 --width=575 --column="$NAME" --column="$PARTLABEL" --column="$SIZEINGIB" --column="$SIZEINMIB" --button=$"gtk-quit:3" --button=$"$USESELECTED:2" --text="    $SELECTROOTPART.\n" "${PartDriveMenu[@]}" )

ret="$?"



if [ "$ret" = "252" ]; then
 SelectRootPart
 exit 0
elif [ "$ret" = "3" ]; then
   $Question --text="$CXLRESTORE"
  if [ "$?" = "0" ]; then
   if [ -f /tmp/Finished-Menu ]; then
    rm /tmp/Finished-Menu
   fi
   exit 1
  else
   SelectRootPart
   exit 0
  fi
elif [ "$TargetPart" = "" ]; then
 SelectRootPart
 exit 0
fi

TargetPart=$(echo "$TargetPart" | awk -F '|' '{print $1}')


## Since unlike the salineos-installer this utility can be run from a non live envoirnment
## We need to make sure that the user doesn't try to install to the current partition
RootDir="$(mount | grep -B 0 ' / ')"

if [ "$(echo "$RootDir" | grep "$TargetPart")" != "" ]; then
 $Info --wrap --width=300 --text="$CANNOTERASEPART\n"
 SelectRootPart
fi

if [ -f /tmp/Finished-Menu ]; then
 FinishedMenu
 exit 0
else
 SwapFile
 exit 0
fi


}



## Choose the drive to partition

ChooseDrive () { 

GrubMenu=""
PartDriveMenu=""
PartDrive=""

Drives=$(cat /proc/partitions | grep -v loop | grep -v major | grep -v "^$" | awk '{print $4}' | grep -v "[0-9]")

for i in $Drives; do
PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')
## Part Drive Size is in blocks, first we need to convert the blocks to bytes
## Don't bother with extended partitions

BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))

if [ "$(echo "$i" | grep [0-9] )" = "" ]; then
 if [ "$PartDriveMenu" = "" ]; then
  PartDriveMenu=( "$i" "$SizeInGB" "$SizeInMB" )
 else
  PartDriveMenu=( "${PartDriveMenu[@]}" "$i" "$SizeInGB" "$SizeInMB" )
 fi
 if [ "$GrubMenu" = "" ]; then
  GrubMenu=("$i" "Master boot record of disk")
 else
  GrubMenu=("${GrubMenu[@]}" "$i" "Master boot record of disk")
 fi
fi
done


GrubMenu=("${GrubMenu[@]}" "root" "Root Partition (Advanced)")

if [ "$AutoPart" = "Auto" ]; then
PartDrive=$($Menu --width=425 --height=300 --column="Drive" --column="$SIZEINGIB" --column="$SIZEINMIB" --text="               $SELECTDRIVEEU\n"  --button=$"gtk-quit:3" --button=$"gtk-ok:2" "${PartDriveMenu[@]}")
else
PartDrive=$($Menu --width=425 --height=300 --column="Drive" --column="$SIZEINGIB" --column="$SIZEINMIB" --text="                 $SELECTDRIVEPART\n"  --button=$"gtk-quit:3" --button=$"gtk-ok:2" "${PartDriveMenu[@]}")
fi

ret="$?"



if [ "$ret" = "3" ]; then
  $Question --text="$CXLRESTORE"
  if [ "$?" = "0" ]; then
   if [ -f /tmp/Finished-Menu ]; then
    rm /tmp/Finished-Menu
   fi
   exit 1
  else
   ChooseDrive
   exit 0
  fi
elif [ "$ret" = "252" ]; then
 ChooseDrive
 exit 0
elif [ "$PartDrive" = "" ]; then
 ChooseDrive
 exit 0
fi 


PartDrive=$(echo "$PartDrive" | awk -F '|' '{print $1}')

## Since unlike the salineos-installer this utility can be run from a non live envoirnment
## We need to make sure that the user doesn't try to autopartition the currently used disk.
RootDir="$(mount | grep -B 0 ' / ')"

if [ "$AutoPart" = "Auto" ]; then
 if [ "$(echo "$RootDir" | grep "$PartDrive")" != "" ]; then
  $Info --wrap --width=300 --text="$CANNOTERASE\n"
  AutoPartitioning
 fi
fi
  

## Launch GParted
if [ "$AutoPart" != "Auto" ]; then
 gparted /dev/$PartDrive
fi

if [ "$AutoPart" = "Auto" ]; then
 SwapFile
 exit 0
else
 SelectRootPart
 exit 0
fi

}




## Ask the user if they wish to use automatic partitioning.

AutoPartitioning () {
$Info --width=400 --wrap --text="$AUTOPARTRESTORE\n" --button=$"$PARTMANUAL:3" --button=$"$PARTAUTO:5"

ret="$?"

if [ "$ret" = "252" ]; then
 AutoPartitioning 
 exit 0
elif [ "$ret" = "5" ]; then
 AutoPart="Auto"
 ChooseDrive
 exit 0
elif [ "$ret" = "3" ]; then
 AutoPart="Manual"
 ChooseDrive
 exit 0
fi 

}

SelectBackupImage () {

BackupImage=""

BackupImage=$(yad --file-selection --file-filter "*.backup" --title="SalineOS-Backup" --height=450 --width=600 --text="\n                     $SELECTBACKUP\n" --button=$"gtk-quit:3" --button=$"gtk-ok:2")

ret="$?"


if [ "$ret" = "252" ]; then
 SelectBackupImage
 exit 0
elif [ "$ret" = "3" ]; then
 $Question --text="$CXLRESTORE"
 if [ "$?" = "0" ]; then
  if [ -f /tmp/Finished-Menu ]; then
   rm /tmp/Finished-Menu
  fi
 fi
  exit 1
elif [ "$BackupImage" = "" ]; then
 SelectBackupImage
 exit 0
elif [ "$(echo "$BackupImage" | grep ".backup")"  = "" ]; then
 $Info --button=$"gtk-ok:1" --text="$BackupImage $VALIDBACKUP"
 SelectBackupImage
 exit 0
fi

AutoPartitioning
exit 0


}

## Start Clone to partition code #######################################################################################

StartPartClone () {

yad --width=450 --wrap --window-icon="/usr/share/pixmaps/salineos-backup.png" --title="SalineOS Backup" --text="$CLONEPARTSTART" --button=$"gtk-no:3" --button=$"gtk-yes:5" 

ret="$?"

if [ "$ret" = "5" ]; then
 gparted
fi

ExcludesPartClone

}

ExcludesPartClone () {

Selection=""
Excludes=""
NewExclude=""
CurrentExcludes=""

mkdir -p /etc/salineos-backup

if [ -f /etc/salineos-backup/excludes ]; then
 Excludes=$(cat /etc/salineos-backup/excludes)
fi

CurrentExcludes=$(echo -n "$Excludes" | yad --always-print-result --text-info --height=350 --editable --title="SalineOS Backup" --wrap --width=400 --text="$USBEXCLUDETEXT" --button=$"gtk-cancel:3" --button=$"$ADDNEW:5" --button=$"gtk-ok:2")

ret="$?"

if [ "$ret" = "252" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "5" ]; then
 if [ -f /etc/salineos-backup/excludes ]; then
  rm /etc/salineos-backup/excludes
 fi
 echo "$CurrentExcludes">>/etc/salineos-backup/excludes
 NewExclude=$(yad --file-selection --title="SalineOS Backup" --height=450 --width=600 --directory --text="\n                     $SELECTFORF\n" --button=$"gtk-quit:3" --button=$"gtk-ok:2")
 ret="$?"

 if [ "$ret" = "252" ]; then
  ExcludesPartClone
  exit 0
 elif [ "$ret" = "3" ]; then
  exit 0
 else
  echo "$NewExclude">>/etc/salineos-backup/excludes
  ExcludesPartClone
  exit 0
 fi
else
 if [ -f /etc/salineos-backup/excludes ]; then
  rm /etc/salineos-backup/excludes
 fi
 echo "$CurrentExcludes">>/etc/salineos-backup/excludes
fi


Excludes=$(cat /etc/salineos-backup/excludes)

SelectClonePart

exit 0


}

SelectClonePart () {

TargetPart=""
PartDriveMenu=("")

## Don't display the current root partition as an option
## Don't display the current /home partition as an option
CurrentRootDir=$(mount | grep -B 0 ' / ' | awk '{print $1}')
CurrentHomeDir=$(mount | grep -B 0 ' /home ' | awk '{print $1}')

if [ "$CurrentHomeDir" = "" ]; then
 CurrentHomeDir='No way in hell this will be found'
fi

Partitions=$(cat /proc/partitions | grep -v loop | grep -v "Extended" | grep -v "extended" | grep -v "swap" | grep -v "Swap" | grep -v "Hidden" | grep -v major | grep -v "^$" | awk '{print $4}' | grep -v 'p1' | grep -v "$CurrentRootDir" | grep -v "$CurrentHomeDir")

for i in $Partitions; do
## Get the label of the disk if available
 Label=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$i" | awk '{print $1}' | sed -e 's|\\x20| |g')

if [ "$Label" = "" ]; then
 Label=' '
else
 Label="$Label     "
fi

PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')
## Part Drive Size is in blocks, first we need to convert the blocks to bytes
## Don't bother with extended partitions
if [ "$PartDriveSize" != "1" ]; then
  BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))

fi

if [ "$(echo "$i" | grep [0-9])" != "" ]; then
 if [ "$PartDriveSize" != "1" ]; then
  if [ "$PartDriveMenu" = "" ]; then
   PartDriveMenu=("$i" "$Label" "$SizeInGB" "$SizeInMB")
  else
   PartDriveMenu=("${PartDriveMenu[@]}" "$i" "$Label" "$SizeInGB" "$SizeInMB")
   fi
 fi
fi

done


TargetPart=$($Menu --height=300 --width=575 --column="$NAME" --column="$PARTLABEL" --column="$SIZEINGIB" --column="$SIZEINMIB" --button=$"gtk-cancel:3" --button=$"gtk-ok:2" --text="                    $SELECTCLONEPART\n" "${PartDriveMenu[@]}" )

ret=$?


if [ "$ret" = "252" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$TargetPart" = "" ]; then
 $Info --button=$"gtk-ok:1" --text="     $MUSTSELECTPART     \n"
 SelectClonePart
 exit 0
fi

TargetPart=$(echo "$TargetPart" | awk -F '|' '{print $1}')

SwapFileClonePart
exit 0

}


SwapFileClonePart () {

SwapFileSize=""


SwapFileSize=$($Menu --column="$SIZE" --column=" " --text="$SWAPFILESIZE\n" --button=$"Use Swap Partition (Advanced):3" --button=$"$CONTINUESWAP:2" 8 Megabytes 32 Megabytes 64 Megabytes 128 Megabytes 256 Megabytes 512 Megabytes 1024 Megabytes 2048 "Megabytes $CHOOSETHIS" 3072 Megabytes 4096 Megabytes 5120 Megabytes 6144 Megabytes 8192 Megabytes 16384 Megabytes 30000 Megabytes --height=350 ) 


ret="$?"

if [ "$ret" = "3" ]; then
 UseSwapFile="False"
 SelectSwapClonePart
 exit 0
elif [ "$ret" = "252" ]; then
 SwapFileClonePart
 exit 0 
elif [ "$SwapFileSize" = "" ]; then
 SwapFileClonePart
 exit 0
else
 UseSwapFile="True"
 SwapFileSize=$(echo "$SwapFileSize" | awk -F '|' '{print $1}') 
 HomePartTest="$(fdisk -l | grep '/dev/' | grep -v "Disk" | grep -v 'p1' | grep -v "Extended" | grep -v "$TargetPart" | grep -v "Swap" | grep -v "$CurrentRootDir" | grep -v "$CurrentHomeDir")"
 if [ "$HomePartTest" != "" ]; then
  SelectHomeClonePart
  exit 0
 fi
fi

GrubClonePart

exit 0

}


SelectSwapClonePart () {

SwapPartMenu=""
Swap=""
BlockSize=""

## Find swap partitions and find out which to use.
TargetSwap=$(fdisk -l | grep "swap" | cut -d " " -f1)
TargetSwap=$(echo "$TargetSwap" | sed -r "s/\/dev\///g")


for i in $TargetSwap; do
PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')

## Part Drive Size is in blocks, first we need to convert the blocks to bytes
BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))

if [ "$(echo "$i" | grep [0-9] )" != "" ]; then
 if [ "$SwapPartMenu" = "" ]; then
  SwapPartMenu=("$i" "$SizeInGB" "$SizeInMB")
 else
  SwapPartMenu=("${SwapPartMenu[@]}" "$i" "$SizeInGB" "$SizeInMB")
 fi
fi

done


Swap=$($Menu --width=415 --height=250 --text="            $SWAPPART            \n" --column="$NAME" --column="$SIZEINGIB" --column="$SIZEINMIB" --button=$"gtk-quit:3" --button=$"Use Swap File:5" --button=$"$USESELECTED:2" "${SwapPartMenu[@]}")

ret="$?"



if [ "$ret" = "3" ]; then
  $Question --text="$CXLRESTORE"
  if [ "$?" = "0" ]; then
   exit 1
  else
   SelectSwapClonePart
   exit 0
  fi
elif [ "$ret" = "252" ]; then
 SelectSwapClonePart
 exit 0 
elif [ "$ret" = "5" ]; then
 SwapFileClonePart
 exit 0
elif [ "$Swap" = "" ]; then
 SelectSwapClonePart
 exit 0
else
 HomePartTest="$(fdisk -l | grep '/dev/' | grep -v "Disk" | grep -v 'p1' | grep -v "Extended" | grep -v "$TargetPart" | grep -v "Swap" | grep -v "$CurrentRootDir" | grep -v "$CurrentHomeDir")"
 if [ "$HomePartTest" != "" ]; then
  Swap=$(echo "$Swap" | awk -F '|' '{print $1}')
  SelectHomeClonePart
  exit 0
 fi
 Swap=$(echo "$Swap" | awk -F '|' '{print $1}')
 GrubClonePart
 exit 0
fi

}

SelectHomeClonePart () {

HomePartMenu=""
Partitions=""

Partitions="$(fdisk -l | grep '/dev/' | grep -v "Disk" | grep -v "Extended" | grep -v "$TargetPart" | grep -v "swap" | grep -v 'p1' | grep -v "extended" | grep -v "Hidden" | grep -v "$CurrentRootDir" | grep -v "$CurrentHomeDir" | cut -d " " -f1 | sed 's|/dev/||g')"

for i in $Partitions; do
## Get the label of the disk if available
 Label=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$i" | awk '{print $1}' | sed -e 's|\\x20| |g')

if [ "$Label" = "" ]; then
 Label=' '
else
 Label="$Label     "
fi

PartDriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')
## Part Drive Size is in blocks, first we need to convert the blocks to bytes
## Don't bother with extended partitions
if [ "$PartDriveSize" != "1" ]; then
  BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($PartDriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Bash always removes the decimels causing it to round down, this makes it round up.
 SizeInGB=$(($SizeInGB + 1))

fi

if [ "$(echo "$i" | grep [0-9] )" != "" ]; then
 if [ "$PartDriveSize" != "1" ]; then
  if [ "$HomePartMenu" = "" ]; then
   HomePartMenu=("$i" "$Label" "$SizeInGB" "$SizeInMB")
  else
   HomePartMenu=("${HomePartMenu[@]}" "$i" "$Label" "$SizeInGB" "$SizeInMB")
  fi
 fi
fi

done

HomePart=$($Menu --width="575" --text="  $HOMEPARTLOC\n" --height=400 --column="$NAME" --column="$PARTLABEL" --column="$SIZEINGIB" --column="$SIZEINMIB" --button=$"gtk-quit:3" --button=$"$USESELECTED:2" --button=$"$PUTHOME:5" "${HomePartMenu[@]}")

ret="$?"

if [ "$ret" = "252" ]; then
 SelectHomeClonePart
 exit 0
elif [ "$ret" = "3" ]; then
  $Question --text="$ABORTINSTALL"
  if [ "$?" = "0" ]; then
   exit 0
  else
   SelectHomeClonePart
   exit 0
  fi
elif [ "$ret" = "5" ]; then
 TargetHomePart="root"
 GrubClonePart
 exit 0
elif [ "$HomePart" = "" ]; then
 SelectHomeClonePart
 exit 0
else
 TargetHomePart=$(echo "$HomePart" | awk -F '|' '{print $1}')
  $Question --text="$FORMATHOME, $TargetHomePart?"
  if [ "$?" = "0" ]; then
   FormatHome="True"
  else
   FormatHome="False"
  fi
fi

GrubClonePart

}



GrubClonePart () {

## Need to get the root partition from the user.

Drives=$(cat /proc/partitions | grep -v loop | grep -v "Extended" | grep -v "extended" | grep -v "swap" | grep -v "Swap" | grep -v "Hidden" | grep -v major | grep -v "^$" | awk '{ print $4}')

for i in $Drives; do
PartDrive="$i"
if [ "$(echo "$PartDrive" | grep [0-9] )" = "" ]; then
 GrubMenu=("${GrubMenu[@]}" "$PartDrive" "Master boot record of disk")
fi
done

GrubMenu=("${GrubMenu[@]}" "root" "Root Partition (Advanced)")

GrubLocation=""


GrubLocation=$(yad --list --window-icon="/usr/share/pixmaps/salineos-backup.png" --title="Grub Doctor" --column="$NAME" --column="$DESCRIPTION" --height="300" --width="275" --wrap --button=$"gtk-quit:3" --button=$"gtk-ok:2" --text="   $GRUBSELECT   \n" "${GrubMenu[@]}")

ret="$?"

if [ "$ret" = "3" ]; then
  $Question --text="$CXLCLONING"
  if [ "$?" = "0" ]; then
   exit 0
  else
   GrubClonePart
   exit 0
  fi
elif [ "$ret" = "252" ]; then
  $Question --text="$CXLCLONING"
  if [ "$?" = "0" ]; then
   exit 0
  else
   GrubClonePart
   exit 0
  fi
elif [ "$GrubLocation" = "" ]; then
 $Info --text="$NOLOCATION" --button=$"gtk-ok:1"
 GrubClonePart
 exit 0
fi

GrubLocation=$(echo "$GrubLocation" | awk -F '|' '{print $1}')

if [ "$GrubLocation" = "root" ]; then
 GrubLocation="/dev/$TargetPart"
else
 GrubLocation="/dev/$GrubLocation"
fi

RunClonePart

}

RunClonePart () {

FinalGrub="$FMGRUB $GrubLocation.\n"

if [ "$UseSwapFile" = "True" ]; then
 FinalSwap="A $SwapFileSize $FMSWAP.          \n"
else
 FinalSwap="$Swap $FORMATANDUSED swap.          \n"
fi

FinalTargetPart="$TargetPart $WILLBEFORMATTED $FMROOT.          \n"

if [ "$TargetHomePart" = "" ]; then
 TargetHomePart="root"
fi

if [ "$TargetHomePart" != "root" ]; then
 if [ "$FormatHome" = "True" ]; then
  FinalHomePart="$TargetHomePart $FORMATANDUSED /home.          \n"
 else
  FinalHomePart="$TargetHomePart $WILLNOTFORMAT /home.          \n\
$ANYUSER $TargetHomePart $SAMENAME.    \n"
 fi
else
 FinalHomePart="$FMHOME $TargetPart.          \n"
fi

yad --title="SalineOS Backup" --window-icon="/usr/share/salineos-backup.png" --text="$FinalTargetPart\n$FinalSwap\n$FinalHomePart\n$FinalGrub\n$CONTINUEWITH\n" --button=$"gtk-no:3" --button=$"gtk-yes:5" 

ret="$?"

if [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "252" ]; then
 RunClonePart
 exit 0
fi

$Info --text="$CLOSEAPPS" --wrap --width=250 --button=$"gtk-cancel:3" --button=$"gtk-ok:1"

ret="$?"

if [ "$ret" = "3" ]; then
 MainMenu
 exit 0
fi

## Start the actual meat and potatoes cloning

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="           Preparing disk and partitions           " &

if [ "$(mount | grep $TargetPart)" != "" ]; then
 umount /dev/$TargetPart
 umount -l /dev/$TargetPart
 sleep 3
fi

## Perserve labels set by users in GParted
if [ "$(ls /dev/disk/by-label)" != "" ]; then
 LabelRoot=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$TargetPart" | awk '{print $1}' | sed -e 's|\\x20| |g')
fi
sleep 2
mke2fs -t ext4 /dev/$TargetPart

sleep 2

if [ "$LabelRoot" != "" ]; then
 tune2fs -L "$LabelRoot" /dev/$TargetPart
fi

mkdir -p /Target

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="                   Mounting $TargetPart                   " &

mount /dev/$TargetPart /Target -o rw

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="Configure the filesystem to be checked\nevery 35 mounts" &

tune2fs -c 35 -i 0 /dev/$TargetPart

sleep 3

rm -rf /Target/lost+found

killall -KILL tail

if [ "$TargetHomePart" = "" ]; then
 TargetHomePart="root"
fi

if [ "$TargetHomePart" != "root" ]; then
 if [ "$FormatHome" = "True" ]; then
  tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="           Formatting $TargetHomePart for /home           " &
  umount /dev/$TargetHomePart
  umount -l /dev/$TargetHomePart
  sleep 2
 ## Perserve labels set by users in GParted
 if [ "$(ls /dev/disk/by-label)" != "" ]; then
  LabelHome=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$TargetHomePart" | awk '{print $1}' | sed -e 's|\\x20| |g')
 fi
  sleep 2
  mke2fs -t $FilesystemType /dev/$TargetHomePart
  sleep 3
  if [ "$LabelHome" != "" ]; then
   tune2fs -L "$LabelHome" /dev/$TargetHomePart
  fi
  killall -KILL tail
 fi

 tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="              Mounting $TargetHomePart              " &

 mkdir -p /Target/home

 mount /dev/$TargetHomePart /Target/home -o rw

 tune2fs -c 35 -i 0 /dev/$TargetHomePart

 rm -rf /Target/home/lost+found

 TargetHomeUUID=$(blkid /dev/$TargetHomePart | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')

 ## Get fs type for the home partition in case the user chose not to format it
 HomeFilesystemType=$(mount | grep "/dev/$TargetHomePart" | awk '{print $5}' | awk -F ' ' '{print $1}')

 killall -KILL tail
fi

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="               $GENERATEUUID               " &

TargetPartUUID=$(blkid /dev/$TargetPart | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')
TargetCDRom="/dev/cdrom"

sleep 3

killall -KILL tail

## Make a more accurate progress bar
if [ "$TargetHomePart" = "root" ]; then
 ProgressText="                   $COPYING $TargetPart                   \n"
else
 ProgressText="                   $COPYING $TargetPart $AND $TargetHomePart                  \n"
fi

## Copy the backup image contents to $Target

tail -f /usr/bin/salineos-backup | $Progress --text="$ProgressText" --pulsate &


## Excludes is a bit tricky with rsync this is some vodoo magic
if [ -f /etc/salineos-backup/excludes ]; then
 if [ "$(cat /etc/salineos-backup/excludes)" != "" ]; then
  cp -f /etc/salineos-backup/excludes /tmp/backup-excludes
  sed -i -e 's| |\ |g' /tmp/backup-excludes
 else
  touch /tmp/backup-excludes
 fi
fi


## Add some things to exclude 

echo '/run'>>/tmp/backup-excludes
echo '/boot/grub'>>/tmp/backup-excludes
echo '/run/lock'>>/tmp/backup-excludes
echo '/media'>>/tmp/backup-excludes
echo '/mnt'>>/tmp/backup-excludes
echo '/proc'>>/tmp/backup-excludes
echo '/swap'>>/tmp/backup-excludes
echo '/sys'>>/tmp/backup-excludes
echo '/tmp'>>/tmp/backup-excludes

for i in $(ls /home); do
 echo "/home/$i/local/share/gvfs-metadata">>/tmp/backup-excludes
 echo "/home/$i/.cache">>/tmp/backup-excludes
 echo "/home/$i/.dbus">>/tmp/backup-excludes
 echo "/home/$i/.gvfs">>/tmp/backup-excludes
done


## Remove duplicate home folders

if [ "$TargetHomePart" != "root" ]; then
if [ "$FormatHome" != "True" ]; then
 for i in $(ls /home); do
  if [ "$(grep "$i$" /tmp/backup-excludes)" = "" ]; then
   if [ -d /Target/home/"$i" ]; then
    rm -rf /Target/home/"$i"
   fi
  fi
 done
fi
fi

## Rsync
rsync -a / /Target --ignore-existing --exclude-from=/tmp/backup-excludes



sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --text="                    $SETUPSWAP                    " --pulsate &


if [ "$UseSwapFile" = "True" ]; then
 mkdir -p /Target/swap
 fallocate --l "$SwapFileSize"m /Target/swap/salineos-swap
 sleep 2
 mkswap /Target/swap/salineos-swap
 SwapFstab="/swap/salineos-swap"
else
 mkswap "$Swap"
 sleep 2
 blkid
 sleep 2
 TargetSwapUUID=$(blkid /dev/$Swap | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')
 SwapFstab="UUID=$TargetSwapUUID"
fi

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --text="$CHANGECONFIG" --pulsate &

## Make sure all directories are present
mkdir -p /run/lock
mkdir -p /Target/etc
mkdir -p /Target/usr
mkdir -p /Target/proc
mkdir -p /Target/tmp
mkdir -p /Target/selinux
mkdir -p /Target/home
mkdir -p /Target/bin
mkdir -p /Target/include
mkdir -p /Target/lib
mkdir -p /Target/opt
mkdir -p /Target/srv
mkdir -p /Target/media
mkdir -p /Target/mnt
mkdir -p /Target/dev
mkdir -p /Target/sys
mkdir -p /Target/boot
mkdir -p /Target/sbin
mkdir -p /Target/run

## Remove old fstab file
rm -rf /Target/etc/fstab

if [ -f /Target/lost+found ]; then
 rm -rf /Target/lost+found
fi

## Create a new fstab file for the system


if [ "$TargetHomePart" = "root" ]; then
cat > /Target/etc/fstab <<FOO
# /etc/fstab: static file system information.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

proc /proc proc defaults 0 0
# Root was on /dev/$TargetPart during install
UUID=$TargetPartUUID / ext4 relatime,errors=remount-ro 0 1
# Swap space created during install
$SwapFstab none swap sw 0 0
# cdrom
$TargetCDRom /media/cdrom udf,iso9660 user,noauto,exec,utf8 0 0


FOO

else

cat > /Target/etc/fstab <<FOO
# /etc/fstab: static file system information.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

proc /proc proc defaults 0 0
# Root was on /dev/$TargetPart during install
UUID=$TargetPartUUID / ext4 relatime,errors=remount-ro 0 1
# /dev/$TargetHomePart home
UUID=$TargetHomeUUID /home $HomeFilesystemType relatime 0 0
# Swap space created during install
$SwapFstab none swap sw 0 0
# cdrom
$TargetCDRom /media/cdrom udf,iso9660 user,noauto,exec,utf8 0 0


FOO

fi

## Make the users on the system own their home folders and fix permissions.
for i in $(ls /Target/home); do
 chown -R "$i" /Target/home/"$i"
 chmod og+rw /Target/home/"$i"
done

## Fix permissions on /tmp
chmod og+rw /Target/tmp

sleep 3

killall -KILL tail


## Update GRUB2

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="               $INSTALLGRUB               \n" &

## Prepare a chroot envoirnment for post install changes

mount -o bind /proc /Target/proc
mount -o bind /dev /Target/dev
mount -o bind /sys /Target/sys

chroot /Target chmod -x /etc/grub.d/20_memtest86+
sleep 2
chroot /Target grub-install --force --no-floppy "$GrubLocation"
sleep 2
chroot /Target update-grub
sleep 2
umount /Target/home
sleep 2
umount /Target/proc
sleep 2
umount /Target/dev
sleep 2
umount /Target/sys
sleep 2

umount -l /Target

sleep 2

grub-install --force --no-floppy "$GrubLocation"

sleep 2

update-grub

sleep 2

killall -KILL tail



$Info --wrap --width=250 --text="            $CLONECOMPLETE            \n" --button=$"gtk-ok:1" 

exit 0


}

## End Clone to partition code #########################################################################################




## Start Clone to USB code #########################################################################################



StartUSBClone () {

USBDrives=""

## Check to make sure that is at least one USB drive connected to the system.
## Without this code the user will be displayed something REALLY ugly
## Pay no mind to the man behind the curtain :)

USBDrives=""
if [ "$(ls /dev/disk/by-path | grep 'usb')" != "" ]; then
 USBDriveTemp=$(find /dev/disk/by-path/* -printf %f" "%l\\n | grep -v part | grep "usb" | awk '{print $2}' | sed -e 's|../../||g')

for i in $USBDriveTemp; do 
 DriveTest=$(cat /var/log/messages | grep "$i" | grep "removable disk" | tail -1)
 DriveTestTwo=$(grep "$i" /proc/partitions)
 
 if [ "$DriveTest" != "" ]; then
 if [ "$DriveTestTwo" != "" ]; then
  if [ "$USBDrives" = "" ]; then
   USBDrives="$i"
  else
   USBDrives="$USBDrives $i"
  fi
 fi
 fi

done
fi

## Error out if no USB drive is found
if [ "$USBDrives" = "" ]; then
 yad --window-icon="/usr/share/pixmaps/salineos-backup.png" --title="SalineOS Backup" --text="      $NODRIVES      \n" --width=250 --button=$"gtk-ok:1"
 exit 0 
fi

USBDriveMenu=""

for i in $USBDrives; do
## Get the label of the disk if available
 Label=$(find /dev/disk/by-label/* -printf %f" "%l\\n | grep "$i" | awk '{print $1}' | sed -e 's|\\x20| |g')

if [ "$Label" = "" ]; then
 Label=' '
else
 Label="$Label     "
fi

DriveSize=$(grep -m 1 "$i" /proc/partitions | awk '{print $3}')

## Part Drive Size is in blocks, first we need to convert the blocks to bytes
 BlockSize=$(df -P /dev/$i | grep "blocks" | awk '{print $2}' | awk -F '-' '{print $1}')
## Multiply blocks by block size to get bytes
 SizeInBytes=$(($DriveSize * $BlockSize))
## Divide Bytes by 1024 to get Kilobytes
 SizeInKB=$(($SizeInBytes / 1024))
## Divide Kilobytes by 1024 to get Megabytes
 SizeInMB=$(($SizeInKB / 1024))
## Divide Megabytes by 1024 to get Gigabytes
 SizeInGB=$(($SizeInMB / 1024))
## Round up on Gigabytes
 SizeInGB=$(($SizeInGB + 1))

if [ "$USBDriveMenu" = "" ]; then
 USBDriveMenu=("$i" "$Label" "$SizeInGB" "$SizeInMB")
else
 USBDriveMenu=("$i" "$Label" "$SizeInGB" "$SizeInMB" "${USBDriveMenu[@]}")
fi

done


UseDrive=$(yad --height="350" --list  --window-icon="/usr/share/pixmaps/salineos-backup.png" --title="SalineOS Backup" --column="$NAME" --column="$ASLABEL(s)" --column="$SIZEINGIB" --column="$SIZEINMIB" --print-column=1 --button=$"gtk-quit:3" --button=$"gtk-ok:2" --text="                            $SELECTDRIVE.                            \n" "${USBDriveMenu[@]}")

ret="$?"

if [ "$ret" = "3" ]; then
 exit 0
elif [ "$ret" = "252" ]; then
 MainMenu
 exit 0 
elif [ "$UseDrive" = "" ]; then
 yad --window-icon="/usr/share/pixmaps/salineos-backup.png" --title="SalineOS Backup" --text="$NOUSB" --button=$"gtk-ok:1"
 StartUSBClone
 exit 0
fi

UseDrive=$(echo "$UseDrive" | awk -F '|' '{print $1}')

ExcludesUSBClone

exit 0

}

ExcludesUSBClone () {

Selection=""
Excludes=""
NewExclude=""
CurrentExcludes=""

mkdir -p /etc/salineos-backup

if [ -f /etc/salineos-backup/excludes ]; then
 Excludes=$(cat /etc/salineos-backup/excludes)
fi

CurrentExcludes=$(echo -n "$Excludes" | yad --always-print-result --text-info --height=350 --editable --title="SalineOS Backup" --wrap --width=400 --text="$USBEXCLUDETEXT." --button=$"gtk-cancel:3" --button=$"Add New:5" --button=$"gtk-ok:2")

ret="$?"

if [ "$ret" = "252" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "5" ]; then
 if [ -f /etc/salineos-backup/excludes ]; then
  rm /etc/salineos-backup/excludes
 fi
 echo "$CurrentExcludes">>/etc/salineos-backup/excludes
 NewExclude=$(yad --file-selection --title="SalineOS Backup" --height=450 --width=600 --directory --text="\n                     $SELECTFORF\n" --button=$"gtk-quit:3" --button=$"gtk-ok:2")
 ret="$?"

 if [ "$ret" = "252" ]; then
  ExcludesUSBClone
  exit 0
 elif [ "$ret" = "3" ]; then
  exit 0
 else
  echo "$NewExclude">>/etc/salineos-backup/excludes
  ExcludesUSBClone
  exit 0
 fi
else
 if [ -f /etc/salineos-backup/excludes ]; then
  rm /etc/salineos-backup/excludes
 fi
 echo "$CurrentExcludes">>/etc/salineos-backup/excludes
fi


Excludes=$(cat /etc/salineos-backup/excludes)

SwapFileUSBClone

exit 0


}


SwapFileUSBClone() {

SwapFileSize=""


SwapFileSize=$($Menu --column="Size" --column=" " --text="  Please select the size of the swap file to be created.\n"  --button=$"gtk-ok:2" 8 Megabytes 32 Megabytes 64 Megabytes 128 Megabytes 256 Megabytes 512 Megabytes 1024 Megabytes 2048 "Megabytes $CHOOSETHIS" 3072 Megabytes 4096 Megabytes 5120 Megabytes 6144 Megabytes 8192 Megabytes 16384 Megabytes 30000 Megabytes --height=350 ) 


ret="$?"


if [ "$ret" = "252" ]; then
 SwapFileUSBClone
 exit 0 
elif [ "$SwapFileSize" = "" ]; then
 SwapFileUSBClone
 exit 0
else
 UseSwapFile="True"
 SwapFileSize=$(echo "$SwapFileSize" | awk -F '|' '{print $1}') 
fi

ConfirmUSBClone

exit 0

}

ConfirmUSBClone () {

yad --title="SalineOS Backup" --wrap --width="250" --window-icon="/usr/share/pixmaps/salineos-backup.png" --text="$USBWARN $UseDrive $USBWARN1" --button=$"gtk-no:3" --button=$"gtk-yes:5"

ret="$?"

if [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "252" ]; then 
 MainMenu
 exit 0
fi

RunUSBClone

exit 0

}

RunUSBClone () {

$Info --text="$CLOSEAPPS" --wrap --width=250 --button=$"gtk-cancel:3" --button=$"gtk-ok:1"

ret="$?"

if [ "$ret" = "3" ]; then
 MainMenu
 exit 0
elif [ "$ret" = "252" ]; then
 MainMenu
 exit 0
fi


## Start the actual meat and potatoes cloning

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="           $PREPDISK           " &

parted --script --align optimal /dev/$UseDrive mklabel msdos
parted --script --align optimal /dev/$UseDrive mkpart primary 1 -- -1
parted --script --align optimal /dev/$UseDrive set 1 boot on
TargetHomePart="root"
TargetPart="$UseDrive"1

## Unmount all partitions on the disk

MountedPartitions="$(mount | grep "$UseDrive" | awk '{print $1}')"

for i in $MountedPartitions; do
 umount /dev/$i
 umount -l /dev/$i
 sleep 3
done

sleep 2
mke2fs -t ext4 /dev/$TargetPart

sleep 2

mkdir -p /Target

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="                   Mounting $TargetPart                   " &

mount /dev/$TargetPart /Target -o rw

sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="Configure the filesystem to be checked\nevery 35 mounts" &

tune2fs -c 35 -i 0 /dev/$TargetPart

sleep 3

rm -rf /Target/lost+found

killall -KILL tail

## Make sure TargetHomePart is set
if [ "$TargetHomePart" = "" ]; then
 TargetHomePart="root"
fi

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="               $GENERATEUUID               " &

TargetPartUUID=$(blkid /dev/$TargetPart | awk -F 'UUID="' '{print $2}' | awk -F '"' '{print $1}')
TargetCDRom="/dev/cdrom"

sleep 3

killall -KILL tail

## Make a more accurate progress bar
ProgressText="            $COPYING $UseDrive $NOW            \n."

## Start the progress bar for copying files

tail -f /usr/bin/salineos-backup | $Progress --text="$ProgressText" --pulsate &


## Excludes is a bit tricky with rsync this is some vodoo magic
if [ -f /etc/salineos-backup/excludes ]; then
 if [ "$(cat /etc/salineos-backup/excludes)" != "" ]; then
  cp -f /etc/salineos-backup/excludes /tmp/backup-excludes
  sed -i -e 's| |\ |g' /tmp/backup-excludes
 else
  touch /tmp/backup-excludes
 fi
fi


## Add some things to exclude 

echo '/run'>>/tmp/backup-excludes
echo '/boot/grub'>>/tmp/backup-excludes
echo '/run/lock'>>/tmp/backup-excludes
echo '/media'>>/tmp/backup-excludes
echo '/mnt'>>/tmp/backup-excludes
echo '/proc'>>/tmp/backup-excludes
echo '/swap'>>/tmp/backup-excludes
echo '/sys'>>/tmp/backup-excludes
echo '/tmp'>>/tmp/backup-excludes

for i in $(ls /home); do
 echo "/home/$i/local/share/gvfs-metadata">>/tmp/backup-excludes
 echo "/home/$i/.cache">>/tmp/backup-excludes
 echo "/home/$i/.dbus">>/tmp/backup-excludes
 echo "/home/$i/.gvfs">>/tmp/backup-excludes
done



## Rsync
rsync -a / /Target --ignore-existing --exclude-from=/tmp/backup-excludes



sleep 3

killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --text="                    $SETUPSWAP                    " --pulsate &

## Create a swap file
mkdir -p /Target/swap
fallocate --l "$SwapFileSize"m /Target/swap/salineos-swap
sleep 2
mkswap /Target/swap/salineos-swap
SwapFstab="/swap/salineos-swap"


killall -KILL tail

tail -f /usr/bin/salineos-backup | $Progress --text="$CHANGECONFIG" --pulsate &

## Make sure all directories are present
mkdir -p /run/lock
mkdir -p /Target/etc
mkdir -p /Target/usr
mkdir -p /Target/proc
mkdir -p /Target/tmp
mkdir -p /Target/selinux
mkdir -p /Target/home
mkdir -p /Target/bin
mkdir -p /Target/lib
mkdir -p /Target/opt
mkdir -p /Target/srv
mkdir -p /Target/media
mkdir -p /Target/mnt
mkdir -p /Target/dev
mkdir -p /Target/sys
mkdir -p /Target/boot
mkdir -p /Target/sbin
mkdir -p /Target/run

## Remove old fstab file
rm -rf /Target/etc/fstab

if [ -f /Target/lost+found ]; then
 rm -rf /Target/lost+found
fi

## Create a new fstab file for the system


cat > /Target/etc/fstab <<FOO
# /etc/fstab: static file system information.
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>

proc /proc proc defaults 0 0
# Root was on /dev/$TargetPart during install
UUID=$TargetPartUUID / ext4 relatime,errors=remount-ro 0 1
# Swap space created during install
$SwapFstab none swap sw 0 0
# cdrom
$TargetCDRom /media/cdrom udf,iso9660 user,noauto,exec,utf8 0 0


FOO

## Make the users on the system own their home folders and fix permissions.
for i in $(ls /Target/home); do
 chown -R "$i" /Target/home/"$i"
 chmod og+rw /Target/home/"$i"
done

## Fix permissions on /tmp
chmod og+rw /Target/tmp

sleep 3

killall -KILL tail


## Update GRUB2

tail -f /usr/bin/salineos-backup | $Progress --pulsate --text="               $INSTALLING GRUB2               \n" &

## Prepare a chroot envoirnment for post install changes

mount -o bind /proc /Target/proc
mount -o bind /dev /Target/dev
mount -o bind /sys /Target/sys

chroot /Target chmod -x /etc/grub.d/20_memtest86+
sleep 2
chroot /Target grub-install --force --no-floppy "/dev/$UseDrive"
sleep 2
chroot /Target update-grub
sleep 2
umount /Target/home
sleep 2
umount /Target/proc
sleep 2
umount /Target/dev
sleep 2
umount /Target/sys
sleep 2

umount -l /Target


sleep 2

killall -KILL tail



$Info --wrap --width=250 --text="            $CLONECOMPLETE            \n" --button=$"gtk-ok:1" 

MainMenu

exit 0

}

## End Clone to USB code ###########################################################################################

MainMenu () {

MainMenuArray=("")

MainMenuArray=( "Clone To Partition" "$CLONEOPTION(s)" "Clone To USB" "$CLONEUSBOPTION" "Create Backup Image" "$CREATEBACKUP" "Restore Backup Image" "$RESTOREBACKUP(s)" )

Action=$(yad --list --title="SalineOS Backup" --column="Action" --column="Description" --print-column="1" --wrap  --width=650 --height=300 --text="$WELCOMETEXT." --button=$"gtk-quit:5" --button=$"gtk-ok:2" "${MainMenuArray[@]}")

ret="$?"

Action=$(echo "$Action" | awk -F '|' '{print $1}')

if [ "$ret" = "252" ]; then
 exit 0
elif [ "$ret" = "5" ]; then
 exit 0
elif [ "$Action" = "Clone To Partition" ]; then
 StartPartClone
 exit 0
elif [ "$Action" = "Clone To USB" ]; then
 StartUSBClone
 exit 0
elif [ "$Action" = "Create Backup Image" ]; then
 BackupPart="root"
 SetExcludes
 exit 0
elif [ "$Action" = "Restore Backup Image" ]; then
 SelectBackupImage
 exit 0
elif [ "$Action" = "Create USB Restore Drive" ]; then
 CreateUSB
 exit 0
elif [ "$Action" = "Update USB Restore Drive" ]; then
 GetDrive
 exit 0
elif [ "$Action" = "Create Restore Partition" ]; then
 CreateRestorePart
 exit 0
elif [ "$Action" = "Update Restore Partition" ]; then
 UpdateRestorePart
 exit 0
elif [ "$Action" = "" ]; then
 yad --title="SalineOS Backup" --text="$SELECTOPTION.\n" --button=$"gtk-ok:1"
 MainMenu
 exit 0
fi

}


## Check for root and cry like a little girl if we don't have it.

TestRoot="$(whoami)"

if [ "$TestRoot" != "root" ]; then
 $Info --button=$"gtk-quit:1" --text="     SalineOS Backup $MUSTROOT.     \n"
 exit 1
fi

if [ "$1" = "Restore" ]; then
 BackupImage="$2"
## Check to make sure we are passed a valid .backup file
 if [ "$(echo "$BackupImage" | grep ".backup")" = "" ]; then
  $Info --wrap --width=250 --button=$"gtk-quit:1" --text="$VALIDFILE.\n"
  exit 0
 fi
 AutoPartitioning
else
 MainMenu
fi

exit
